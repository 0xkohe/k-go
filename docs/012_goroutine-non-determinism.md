# Goroutineの非決定性について

## はい、現在の実装は非決定的です

K Frameworkでの並行実行は**非決定的（non-deterministic）**に動作します。これはGo言語の実際のgoroutineの動作を正確に反映しています。

## K Frameworkにおける非決定性

### 複数スレッドの実行順序

K Frameworkでは、複数の `<thread>` セルが存在する場合、どのスレッドのどのルールを次に適用するかは非決定的に選択されます。

```k
<threads>
  <thread>
    <tid> 0 </tid>
    <k> print(1); go printNum(42); print(2); </k>
  </thread>
</threads>
```

このコードから以下のような実行が可能：

### 可能な実行シーケンス

#### シーケンス1
```
1. スレッド0: print(1) → 出力: 1
2. スレッド0: go printNum(42) → スレッド1を生成
3. スレッド0: print(2) → 出力: 2
4. スレッド1: printNum(42) → 出力: 42

結果: 1, 2, 42
```

#### シーケンス2
```
1. スレッド0: print(1) → 出力: 1
2. スレッド0: go printNum(42) → スレッド1を生成
3. スレッド1: printNum(42) → 出力: 42
4. スレッド0: print(2) → 出力: 2

結果: 1, 42, 2
```

#### シーケンス3（細かいインターリーブ）
```
1. スレッド0: print(1) → 出力: 1
2. スレッド0: go printNum(42) → スレッド1を生成
3. スレッド1: printNum(42) の関数呼び出し開始
4. スレッド0: print(2) → 出力: 2
5. スレッド1: print(42) → 出力: 42

結果: 1, 2, 42
```

## チャネル通信における非決定性

### ブロッキングによる制約

チャネル通信では、ブロッキング・セマンティクスにより実行順序に**制約**が加わりますが、依然として非決定的です。

**例:**
```go
ch := make(chan int)
go func1(ch)
go func2(ch)
result := <-ch
```

**可能なシナリオ:**

#### シナリオ1: func1が先に送信
```
1. メインスレッド: ch作成
2. メインスレッド: go func1(ch) → スレッド1生成
3. メインスレッド: go func2(ch) → スレッド2生成
4. メインスレッド: <-ch でブロック
5. スレッド1: ch <- 100 → メインスレッド再開
6. メインスレッド: result = 100 を受信

結果: メインは100を受信
```

#### シナリオ2: func2が先に送信
```
1. メインスレッド: ch作成
2. メインスレッド: go func1(ch) → スレッド1生成
3. メインスレッド: go func2(ch) → スレッド2生成
4. メインスレッド: <-ch でブロック
5. スレッド2: ch <- 200 → メインスレッド再開
6. メインスレッド: result = 200 を受信

結果: メインは200を受信
```

### キューによる順序保証

ただし、同じチャネルに対する送信/受信は**FIFO（先入れ先出し）**の順序で処理されます：

```k
syntax ChanState ::= chanState(List, List, Type)
// chanState(送信待ちキュー, 受信待ちキュー, 要素型)
```

**例:**
```go
ch := make(chan int)
go sender1(ch, 100)  // スレッド1
go sender2(ch, 200)  // スレッド2
```

もしスレッド1が先に `ch <- 100` を実行してブロックし、その後スレッド2が `ch <- 200` を実行してブロックした場合：

```
<channels>
  0 |-> chanState(
    ListItem(sendItem(1, 100)) ListItem(sendItem(2, 200)),  // 送信キュー（FIFO）
    .List,
    int
  )
</channels>
```

受信側が `<-ch` を2回実行すると：
1. 最初の受信: 100 を受け取る（スレッド1から）
2. 2回目の受信: 200 を受け取る（スレッド2から）

## 非決定性の確認方法

### 方法1: search コマンド（要再コンパイル）

K Frameworkの `search` コマンドで全ての可能な実行パスを探索できます：

```bash
# 再コンパイル（searchモード有効化）
kompile main.k --enable-search

# 全ての実行パスを探索
krun codes/code-goroutine-simple --search
```

これにより、全ての可能な実行結果が列挙されます。

### 方法2: 複数回実行

LLVMバックエンドでは、各実行は内部的にランダム性を持つ可能性があります（実装依存）。ただし、通常は決定的な一つのパスを選択します。

### 方法3: 明示的な競合を作る

**テストコード:**
```go
package main

func worker(id int) {
    print(id);
}

func main() {
    go worker(1);
    go worker(2);
    go worker(3);
}
```

このコードでは、1, 2, 3 の出力順序は非決定的です。

## 実際のGo言語との比較

### Go言語の動作

実際のGo言語でも、goroutineのスケジューリングは非決定的です：

```go
package main
import "fmt"

func main() {
    go fmt.Println("A")
    go fmt.Println("B")
    go fmt.Println("C")
    time.Sleep(time.Second)  // goroutineの完了を待つ
}
```

このプログラムを複数回実行すると、出力順序が変わることがあります：
- 実行1: A, B, C
- 実行2: B, A, C
- 実行3: C, A, B

### K実装の忠実性

私たちのK実装は、この非決定的な動作を正確にモデル化しています：

1. **スケジューリングの非決定性**: どのスレッドが次に実行されるかは非決定的
2. **チャネルの順序保証**: 同じチャネルのキューはFIFO
3. **ブロッキング**: 送信/受信の同期は正確に実装

## 決定的実行への拡張方法

もし決定的な実行が必要な場合、以下の方法で実装できます：

### 1. ラウンドロビン・スケジューラ

```k
configuration
  <scheduler> 0 </scheduler>  // 現在のスレッドID
  <threads> ... </threads>

// スレッドIDの順番で実行
rule <k> ... </k>
     <tid> Tid </tid>
     <scheduler> Tid => (Tid +Int 1) modInt TotalThreads </scheduler>
```

### 2. 優先度ベース・スケジューラ

```k
<thread>
  <tid> ... </tid>
  <priority> 10 </priority>  // 優先度
  ...
</thread>

// 高優先度のスレッドを先に実行
```

### 3. 協調的スケジューリング

```k
syntax KItem ::= "yield"

rule <k> yield => .K ... </k>
     <tid> Tid </tid>
     <scheduler> _ => nextThread(Tid) </scheduler>
```

## まとめ

### 現在の実装の特徴

✅ **非決定的**: 複数のスレッドの実行順序は非決定的
✅ **Go仕様に準拠**: 実際のGo言語の動作を正確にモデル化
✅ **FIFO保証**: チャネルのキューは順序を保証
✅ **ブロッキング**: 送信/受信の同期は正確

### 非決定性の利点

1. **正確なモデル**: 実際のgoroutineの動作を反映
2. **バグ検出**: `search` で全実行パスを探索し、競合状態を発見
3. **検証**: 全ての可能な実行で正しい動作を確認

### 非決定性の注意点

⚠️ **データ競合**: 共有変数への並行アクセスは未定義動作
⚠️ **デバッグ**: 実行ごとに結果が変わる可能性
⚠️ **再現性**: 特定の実行パスを再現するには追加の工夫が必要

---

**結論**: 現在の実装は意図的に非決定的であり、これはGo言語のgoroutineの正確なセマンティクスを表現しています。
