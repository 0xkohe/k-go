 func pair() (int, int) {
      var a int = 1;
      var b int = 2;
      return a, b;
  }

  func main() {
      x, y := pair();
      print(x);
      print(y);
  }

  実行フロー図

  ┌─────────────────────────────────────────────────────────────────┐
  │ 1. プログラム開始: main関数のBodyを実行                          │
  │    src/go/semantics/core.k:29                                   │
  │    <k> x, y := pair(); print(x); print(y) </k>                  │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 2. 多変数短縮宣言を検出                                          │
  │    src/go/syntax/core.k:64 (ShortVarDecl構文マッチ)             │
  │    IL:IdentifierList := ExpressionList                          │
  │    ※ strict属性なし → 手動評価                                  │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 3. evalForDeclare ヘルパーに変換                                │
  │    src/go/semantics/core.k:117                                  │
  │    rule: IL := (E, .ExpressionList) => evalForDeclare(IL, E)   │
  │    <k> evalForDeclare((x, y), pair()) </k>                      │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 4. 関数呼び出しを評価（contextルールでHEAT）                     │
  │    src/go/semantics/core.k:120                                  │
  │    context evalForDeclare(_, HOLE:KItem)                        │
  │    <k> pair() ~> #freezer... </k>                               │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 5. 関数呼び出しルール適用                                        │
  │    src/go/semantics/func.k:22                                   │
  │    rule: F(AL) => enterScope(bindParams(...) ~> B) ~> returnJoin│
  │    <k> enterScope(var a int = 1; var b int = 2; return a, b;)  │
  │         ~> exitScope ~> returnJoin((int, int, .ParameterList)) │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 6. 関数Body実行: 変数宣言                                        │
  │    src/go/semantics/core.k:57,61                                │
  │    rule: var X int = I => .K (envIに保存)                       │
  │    <envI> a |-> 1, b |-> 2 </envI>                              │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 7. return文に到達                                               │
  │    src/go/syntax/func.k:37 (ExpressionListとしてパース)         │
  │    <k> return a, b, .ExpressionList </k>                        │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 8. ExpressionListの長さチェック                                 │
  │    src/go/semantics/func.k:42-43                                │
  │    rule: return EL => evalReturnList(EL, .List)                 │
  │         requires lenExpList(EL) >=Int 2                         │
  │    <k> evalReturnList((a, b, .ExpressionList), .List) </k>      │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 9. 最初の要素を評価（変数aを値1に）                              │
  │    src/go/semantics/func.k:56 (contextルールでHEAT)             │
  │    context evalReturnList((HOLE, _), _)                         │
  │    src/go/semantics/core.k:130 (変数lookup)                     │
  │    rule: X => I (envIから取得)                                  │
  │    <k> evalReturnList((1, b, .ExpressionList), .List) </k>      │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 10. 評価済み要素をアキュムレータに追加                           │
  │     src/go/semantics/func.k:46-47                               │
  │     rule: evalReturnList((V:Int, Rest), Acc)                    │
  │           => evalReturnList(Rest, Acc ListItem(V))              │
  │     <k> evalReturnList((b, .ExpressionList), ListItem(1)) </k>  │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 11. 2番目の要素を評価（変数bを値2に）                           │
  │     src/go/semantics/func.k:57 (contextルールでHEAT)            │
  │     context evalReturnList(HOLE, _)                             │
  │     src/go/semantics/core.k:130 (変数lookup)                    │
  │     <k> evalReturnList(2, ListItem(1)) </k>                     │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 12. 最後の要素処理 → tuple作成                                  │
  │     src/go/semantics/func.k:50-51                               │
  │     rule: evalReturnList(V:Int, Acc)                            │
  │           => returnTuple(tuple(Acc ListItem(V)))                │
  │     <k> returnTuple(tuple(ListItem(1) ListItem(2))) </k>        │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 13. tupleをreturnSignalに変換                                   │
  │     src/go/semantics/func.k:60                                  │
  │     rule: returnTuple(T) => returnSignal(T)                     │
  │     <k> returnSignal(tuple(...)) </k>                           │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 14. returnSignalがexitScopeを通過                               │
  │     src/go/semantics/func.k:62                                  │
  │     rule: returnSignal(V) ~> exitScope                          │
  │           => exitScope ~> returnSignal(V)                       │
  │     (スコープを抜けて環境をリストア)                             │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 15. returnJoinでtupleをそのまま返す                             │
  │     src/go/semantics/func.k:50                                  │
  │     rule: returnSignal(tuple(L)) ~> returnJoin(_PS:Parameters)  │
  │           => tuple(L)                                           │
  │     <k> tuple(ListItem(1) ListItem(2)) </k>                     │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 16. evalForDeclareのCOOL（結果を戻す）                          │
  │     <k> evalForDeclare((x, y), tuple(...)) </k>                 │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 17. tupleをdeclareFromTupleで展開                               │
  │     src/go/semantics/core.k:122                                 │
  │     rule: evalForDeclare(IL, tuple(L))                          │
  │           => declareFromTuple(IL, L)                            │
  │     <k> declareFromTuple((x, y), ListItem(1) ListItem(2)) </k>  │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 18. 1つ目の変数を宣言                                           │
  │     src/go/semantics/core.k:124-126                             │
  │     rule: declareFromTuple((X, Rest), ListItem(V:Int) LRest)    │
  │           => declareFromTuple(Rest, LRest)                      │
  │     <tenv> x |-> int </tenv>                                    │
  │     <envI> x |-> 1 </envI>                                      │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 19. 2つ目（最後）の変数を宣言                                   │
  │     src/go/semantics/core.k:128-130                             │
  │     rule: declareFromTuple(X, ListItem(V:Int)) => .K            │
  │     <tenv> x |-> int, y |-> int </tenv>                         │
  │     <envI> x |-> 1, y |-> 2 </envI>                             │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │ 20. print文を順次実行                                           │
  │     src/go/semantics/core.k:54-55                               │
  │     rule: print(I) => .K                                        │
  │     <out> ListItem(1) ListItem(2) </out>                        │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
                            ✅ 完了

  重要なポイント

  🔑 キーとなる3つのフェーズ

  1. 評価フェーズ (ステップ 8-12)
    - evalReturnList が ExpressionList を順番に評価
    - アキュムレータパターンで値を蓄積
    - context ルールで非値式を HEAT/COOL
  2. 返却フェーズ (ステップ 13-15)
    - tuple を returnSignal で包む
    - スコープを抜ける際も保持
    - returnJoin で関数の戻り値として返す
  3. 展開フェーズ (ステップ 16-19)
    - declareFromTuple が tuple を個別変数に分解
    - 再帰的に各要素を処理
    - 型環境と値環境を更新

  📝 使用された主要ファイルとルール

  | ファイル                     | 主要ルール                                         |
  役割                 |
  |--------------------------|-----------------------------------------------|-------------
  -------|
  | syntax/core.k:64         | ShortVarDecl ::= IL := EL                     | 構文定義
             |
  | semantics/core.k:117     | IL := (E, .ExpressionList) => evalForDeclare  | 呼び出し準備
               |
  | semantics/func.k:22      | F(AL) => enterScope(...)                      | 関数実行
             |
  | semantics/func.k:42      | return EL => evalReturnList                   |
  ExpressionList処理開始 |
  | semantics/func.k:46-55   | evalReturnList 各ケース                           |
  要素の評価と蓄積           |
  | semantics/func.k:60      | returnTuple => returnSignal                   | 返却準備
             |
  | semantics/func.k:50      | returnSignal(tuple) ~> returnJoin             | tuple返却
           |
  | semantics/core.k:122     | evalForDeclare(IL, tuple) => declareFromTuple | 展開開始
             |
  | semantics/core.k:124-130 | declareFromTuple 再帰処理                         | 変数宣言
